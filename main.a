!to "mandelbr.prg", cbm
!cpu 65c02

;TESTS = 1

*=$0801
!byte $0c,$08,$e6,$07,$9e,$20,$32,$30,$36,$32,$00,$00,$00

RES_X = 320
RES_Y = 240
MAX_ZOOM_LEVEL = 15
KEY_DO_ZOOM = $87
KEY_DO_SAVE = $88
ITER_DEFAULT = 24

ENTRY_POINT
jmp progStart

!source "zeropage.a"

!zone arith
!source "arith16.a"
!source "arith32.a"

!zone string
!source "string.a"

!zone disk_io
!source "disk_io.a"

!zone vera
!source "vera.a"
!source "memory.a"

!zone main
!source "mandelhelp.a"


; **************************************************
; The following 6 values have to be contiguously laid out
; in memory. The load and save routines expect this.

; x offset to move in complex plane for next point
STEP_X
!byte 0, $66, $66, $02, $00

; Y offset to move in complex plane for next line of picture
STEP_Y
!byte 1, $5C, $8F, $02, $00

; real part of upper left point of picture
INIT_REAL
!byte 1, 0, 0, 0, 2

; imaginary part of upper left point of picture
INIT_IMAG
!byte 0, 0, 0, $25, 1

ZOOM_LEVEL
!byte 0

; maximum number of iterations
MAX_ITER
!byte ITER_DEFAULT
; **************************************************

; Number of points (resolution) in x direction
MAX_X
!byte <RES_X, >RES_X 

; Number of points (resolution) in y direction
MAX_Y 
!byte RES_Y

; current X position
COUNT_X
!byte 0, 0

; current y position
COUNT_Y
!byte 0

; --------------------------------------------------
; variables used for calculation
; --------------------------------------------------

; The number of iterations used for the current point
NUM_ITER
!byte 0

REAL
!byte 0,2,0,0,0

IMAG
!byte 0,3,0,0,0

XN
!byte 0,0,0,0,0

YN
!byte 0,0,0,0,0

XN_OLD
!byte 0,0,0,0,0

TEMP_MAX
!byte 0,0,0,0,0

YN_SQUARE
!byte 0,0,0,0,0

XN_SQUARE
!byte 0,0,0,0,0

; --------------------------------------------------
; constants
; --------------------------------------------------

; The fixed value 4. When a sequence's value is greater or equal to this number
; the sequence defined by the current point diverges
VAL_MAX
!byte 0,0,0,0,4

; x offset to move in complex plane default picture (full resolution)
DEFAULT_STEP_X
!byte 0, $66, $66, $02, $00

; Y offset to move in complex plane for next line of default picture
DEFAULT_STEP_Y
!byte 1, $5C, $8F, $02, $00

; real part of upper left point of default picture
DEFAULT_INIT_REAL
!byte 1, 0, 0, 0, 2

; imaginary part of upper left point of picture default picture
DEFAULT_INIT_IMAG
!byte 0, 0, 0, $25, 1
; **************************************************


!zone main

; --------------------------------------------------
; This routine test if calculation of the Mandelbrot sequence should be stopped.
; It is stopped, when the iteration count reached MAX_ITER of the absolute value
; of the current sequence value is larger than 4
;
; This routine returns a nonzero value if computation has to be stopped. The zero
; flag is cleared in this case.
; --------------------------------------------------
testMandelbrotDone
    lda NUM_ITER
    cmp MAX_ITER
    bne .testLimit
    jmp .stopCalc

.testLimit
    ; *****************************
    ; abs_val = xn*xn + yn*yn
    ; *****************************

    ; XN_SQUARE <= XN
    +callFunc move32Bit, XN, XN_SQUARE
    ; XN_SQUARE <= XN_SQUARE * XN_SQUARE
    +callFuncMono square32BitNormalized, XN_SQUARE
    ; YN_SQUARE <= YN
    +callFunc move32Bit, YN, YN_SQUARE
    ; YN_SQUARE <= YN_SQUARE * YN_SQUARE
    +callFuncMono square32BitNormalized, YN_SQUARE
    ; TEMP_MAX <= XN_SQUARE
    +callFunc move32Bit, XN_SQUARE, TEMP_MAX
    ; TEMP_MAX <= YN_SQUARE + TEMP_MAX
    +callFunc add32Bit, YN_SQUARE, TEMP_MAX

    ; Stop if TEMP_MAX > 4
    ; continue if TEMP_MAX <= 4

    ; Carry is set if TEMP_MAX >= 4
    ; Zero flag is set if TEMP_MAX == 4
    +callFunc cmp32BitUnsigned, TEMP_MAX, VAL_MAX 
    bcs .greaterPerhapsEqual
.continueCalc                ; TEMP_MAX < 4
    lda #0
    rts
.greaterPerhapsEqual         ; TEMP_MAX >= 4
    beq .continueCalc        ; TEMP_MAX == 4? => If yes continue
.stopCalc
    lda #1                   ; TEMP_MAX > 4 => Stop
    rts

; --------------------------------------------------
; This routine calculates the Mandelbrot sequence for the complex value given through
; REAL und IMAG.
;
; The number of iterations performed is returned in NUM_ITER 
; --------------------------------------------------
calcOneMandelbrotSequence
    lda #1
    sta NUM_ITER

    ; REAL <= XN
    +callFunc move32Bit, REAL, XN
    ; YN <= IMAG
    +callFunc move32Bit, IMAG, YN

.loopMandelbrot
    jsr testMandelbrotDone
    beq .continueMandelbrot
    jmp .endMandelbrot

.continueMandelbrot
    ; XN_OLD <= XN
    +callFunc move32Bit, XN, XN_OLD
    
    ; *****************************
    ; xn+1 = xn*xn - yn*yn + real
    ; *****************************

    ; XN <= XN_SQUARE
    +callFunc move32Bit, XN_SQUARE, XN
    ; YN_SQUARE <= -YN_SQUARE
    +callFuncMono neg32, YN_SQUARE
    ; XN <= YN_SQUARE + XN
    +callFunc add32Bit, YN_SQUARE, XN
    ; XN <= REAL + XN
    +callFunc add32Bit, REAL, XN

    ; *****************************
    ; yn+1 = 2*xn*yn + imag
    ; *****************************

    ; YN <= XN_OLD * YN 
    +callFunc mul32BitNormalized, XN_OLD, YN
    ; YN <= 2*YN
    +callFuncMono double32Bit, YN
    ; YN <= IMAG + YN
    +callFunc add32Bit, IMAG, YN 

    inc NUM_ITER
    jmp .loopMandelbrot

.endMandelbrot
    rts

; --------------------------------------------------
; This routine initialises the data needed for computation
;
; initMandel has no return value. 
; --------------------------------------------------
initMandel
    +load16BitImmediate 0, COUNT_X
    lda #0
    sta COUNT_Y
    ; reset complex numbers
    +callFunc move32Bit, INIT_REAL, REAL
    +callFunc move32Bit, INIT_IMAG, IMAG

    rts

; --------------------------------------------------
; This routine performs all necessary calculations for one point in the
; complex plane. Calling this routine repeatedly calculates and draws the
; selected rectangular part of the Mandelbrot set. If COUNT_Y reaches 240
; all pixels have been drawn.
;
; nextMandel has no return value. 
; --------------------------------------------------
nextMandel
    jsr calcOneMandelbrotSequence
    jsr drawPoint
    ; REAL <= STEP_X + REAL
    +callFunc add32Bit, STEP_X, REAL
    +inc16Bit COUNT_X
    +cmp16Bit COUNT_X, MAX_X
    bne .done
    +load16BitImmediate 0, COUNT_X
    ; REAL <= INIT_REAL
    +callFunc move32Bit, INIT_REAL, REAL
    ; IMAG <= STEP_Y + IMAG
    +callFunc add32Bit, STEP_Y, IMAG
    inc COUNT_Y
.done
    rts


.INTERRUPTED
!byte 0

; --------------------------------------------------
; This routine visualizes the Mandelbrot set 
; --------------------------------------------------
mandelLoop
    lda .INTERRUPTED
    bne .resetInterruped
    jsr initMandel
.resetInterruped
    stz .INTERRUPTED

.loopUntilFinished
    jsr nextMandel
    jsr checkKey
    sta .INTERRUPTED
    bne .doneMandel
    lda COUNT_Y
    cmp MAX_Y
    bne .loopUntilFinished
    bra .doneMandel
.doneMandel
    rts


!ifndef TESTS {

.TXT_VALUES
!byte 30
!byte 13
!tx "VALUES USED FOR CALCULATION"
!byte 13, 13

.TXT_REAL_PART
!byte 18
!tx "REAL PART      : $"

.TXT_IMAGINARY_PART
!byte 18
!tx "IMAGINARY PART : $"

.TXT_ZOOM_LEVEL
!byte 17
!tx "ZOOM LEVEL     : "

.TXT_ITERATION_DEPTH
!byte 17
!tx "ITERATION DEPTH: "

.TXT_STEPPING_X
!byte 18
!tx "STEP X         : $"

.TXT_STEPPING_Y
!byte 18
!tx "STEP Y         : $"

.TXT_CONTINUE
!byte 50
!byte 13
!tx "PRESS RETURN TO CONTINUE." 
!byte 13
!tx "ANY OTHER KEY TO QUIT."
!byte 13

; --------------------------------------------------
; This routine performs all neccessary steps for selecting
; a new upper left corner in the set and a new stepping width 
; in X and Y direction (i.e. zomming into the set).
;
; This routine does not return any values.
; --------------------------------------------------
.processZoomResult
    +move16Bit ZOOM_X_POS, COUNT_X
    lda ZOOM_Y_POS
    sta COUNT_Y
    jsr deriveParametersFromPixel
    ldx ZOOM_DIFF
    beq .zoomingDone
.zoomInMore    
    jsr increaseZoomLevel
    dex 
    bne .zoomInMore
.zoomingDone
    rts


.STR_CONV
!byte 3
!byte 0,0,0

; --------------------------------------------------
; This routine prints the upper left corner as real and imaginary part, 
; the zoom level and the iteration depth and allows to recreate the picture
; in absence of a save routine.
;
; It does not return any values.
; --------------------------------------------------
.printLastValues
    +printStr .TXT_VALUES
    +printStr .TXT_REAL_PART
    +printFixedPoint INIT_REAL
    +printStr .TXT_IMAGINARY_PART
    +printFixedPoint INIT_IMAG
    +printStr .TXT_ZOOM_LEVEL
    +itoa ZOOM_LEVEL, .STR_CONV
    +printStr .STR_CONV
    jsr printCRLF
    +printStr .TXT_ITERATION_DEPTH
    +itoa MAX_ITER, .STR_CONV
    +printStr .STR_CONV
    jsr printCRLF
    +printStr .TXT_STEPPING_X
    +printFixedPoint STEP_X
    +printStr .TXT_STEPPING_Y
    +printFixedPoint STEP_Y

    rts


.TXT_SELECT_DEPTH
!byte 40
!tx "SELECT ITERATION DEPTH (24 IS DEFAULT): "

DEC_CHARS
!byte 10
!tx "0123456789"

.BUFFER_DEPTH
!byte 3
!tx 0,0,0

.NEW_DEPTH_RAW
!byte 0,0

; --------------------------------------------------
; This routine allows the user to select an iteration depth
; 
; It does not return a value but modifies MAX_ITER.
; --------------------------------------------------
selectIterationDepth
    +printStr .TXT_SELECT_DEPTH
    lda #3
    sta .BUFFER_DEPTH                                         ; set number of bytes available in input string
    +inputStr .BUFFER_DEPTH, DEC_CHARS                        ; Get input string, as string of digits
    pha                                                       ; save length of entered string
    jsr printCRLF
    pla                                                       ; restore string length
    cmp #0                                                    ; check for empty string
    beq .defaultDepth                                         ; User only pressed return => Use default
    +atoi .BUFFER_DEPTH, .NEW_DEPTH_RAW                       ; Convert string to a number
    +cmp16BitImmediate 254, .NEW_DEPTH_RAW                    ; Value entered was too big => Let's try that again
    bcc selectIterationDepth
    lda .NEW_DEPTH_RAW
    sta MAX_ITER                                              ; Store new value entered by the user
    bra .selectionDone
.defaultDepth    
    lda #ITER_DEFAULT
    sta MAX_ITER                                              ; (Re)store default value
.selectionDone
    rts

.TXT_FILE_NAME
!byte 10
!tx "FILENAME: "

.TXT_LOADING
!byte 12
!tx "LOADING ..."
!byte 13

.TXT_SAVING
!byte 11
!tx "SAVING ..."
!byte 13


ALLOWED_FILE_CHARS
!byte 38
!tx "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ."

; --------------------------------------------------
; This routine saves a picture and the corresponding parameters to disk
; 
; It returns DISK_IO_OK if saving was successfull.
; --------------------------------------------------
savePicture
    +printStr .TXT_FILE_NAME
    lda #MAX_FILE_NAME_LENGTH                            ; restore input buffer cpacity
    sta FILE_NAME_SAVE_LOAD
    +inputStr FILE_NAME_SAVE_LOAD, ALLOWED_FILE_CHARS
    pha
    jsr printCRLF
    pla
    cmp #0
    beq .noSave                                          ; do nothing if user entered an empty string
    +printStr .TXT_SAVING    
    jsr saveHiresDataToDisk                              ; save data from banked RAM to disk
    rts

.noSave
    rts

; --------------------------------------------------
; This routine loads a picture and the corresponding parameters from disk
; 
; It returns DISK_IO_OK if loading was successfull.
; --------------------------------------------------
loadPicture
    +printStr .TXT_FILE_NAME
    lda #MAX_FILE_NAME_LENGTH                           ; restore input buffer cpacity
    sta FILE_NAME_SAVE_LOAD
    +inputStr FILE_NAME_SAVE_LOAD, ALLOWED_FILE_CHARS
    pha
    jsr printCRLF
    pla
    cmp #0
    beq .noLoad                                         ; do nothing if user entered empty string
    +printStr .TXT_LOADING    
    jsr loadHiresDataFromDisk                           ; load data and store it in banked RAM
    rts

.noLoad
    lda #DISK_IO_ERR
    rts

.TXT_SELECT
!byte 68
!tx "1. LOAD PICTURE"
!byte 13
!tx "2. USE CURRENT VALUES"
!byte 13
!tx "3. USE DEFAULT VALUES"
!byte 13
!tx "4. EXIT"
!byte 13

; --------------------------------------------------
; This routine loads a picture, shows it and handles keyboard input
; for zooming in and showing values. If the user decides to zoom into
; the picture this routine jumps (jmp(!!)) into the main routine.
; The main routine therefore calls loadAndShowPicture also with a jmp
; in order to keep the stack clean. This also means that if this routine
; executes rts the program ends.
; 
; The routine has no return values.
; --------------------------------------------------
loadAndShowPicture
    jsr loadPicture
    cmp #DISK_IO_OK
    beq .doShowAfterLoad               ; do nothing if load failed 
    jsr readAndEvalErrorChannel        ; read error channel
    +printStr ERR_BYTE_COUNTER         ; print error message
    jsr printCRLF    
    rts
.doShowAfterLoad      
    jsr bitMapOn                       ; This also clears Video RAM
    jsr restoreHiresData               ; Move loaded data to video RAM
.waitForCommand
    jsr waitForKey
    cmp #KEY_DO_ZOOM
    bne .showValues
    ;
    stz .INTERRUPTED
    jsr showZoomRect                   ; Perform selection of zoomed in section
    lda ZOOM_RESULT
    cmp #ZOOM_ESCAPE                   ; Did user cancel the operation?
    beq .waitForCommand                ; Yes, User escaped from zoom selection
    jsr .processZoomResult             ; Modify state and start values for calculation
    jmp .restart                       ; draw visualization
.showValues
    stz .INTERRUPTED
    jsr showCalcParameters
    cmp #CONST_CONTINUE                ; Does user want to end the program?
    beq .waitForCommand                ; No => continue showing picture
    rts


CONST_CONTINUE = 1
CONST_FINISH = 0

; --------------------------------------------------
; This routine shows the values used for calculation.
; 
; It returns CONST_CONTINUE in the accu if the user has chosen to
; continue the program and CONST_FINISH in case the user
; wants to end the program.
; --------------------------------------------------
showCalcParameters
    jsr saveHiresData                  ; save bitmap in banked RAM
showCalcNoSaveHires
    jsr bitMapOff
    jsr .printLastValues               ; print current values
    +printStr .TXT_CONTINUE
    jsr waitForKey
    cmp #13                            ; user pressed return?
    bne .endShowContinue               ; No => Tell caller user wants to stop 
    jsr bitMapOn
    jsr restoreHiresData               ; restore bitmap from banked RAM    
    lda #CONST_CONTINUE
    rts
.endShowContinue
    lda #CONST_FINISH
    rts


; --------------------------------------------------
; This routine handles the UI operations that occur after the calculation
; has ended. If the user decides to zoom into the picture this routine jumps
; (jmp(!!)) into the main routine. The main routine therefore calls 
; loadAndShowPicture also with a jmp in order to keep the stack clean. 
; This also means that if this routine executes rts the program ends.
; 
; The routine has no return values.
; --------------------------------------------------
handlePicDone
    jsr saveHiresData                  ; save current picture in banked RAM
    
.checkForKeyPress
    jsr waitForKey
    cmp #KEY_DO_ZOOM
    bne .checkForSave
    ; try to zoom in
    jsr showZoomRect                   ; Perform selection of zoomed in section
    lda ZOOM_RESULT
    cmp #ZOOM_ESCAPE  
    beq .checkForKeyPress              ; User has aborted zoom selection
    ; user has selected a new section
    jsr .processZoomResult
    jmp .restart
.checkForSave
    cmp #KEY_DO_SAVE
    bne .showValuesAtEnd

    jsr bitMapOff
    jsr savePicture                    ; save picture if user pressed F7. No error check. The routine generates error messages
    jsr readAndEvalErrorChannel        ; read error channel
    +printStr ERR_BYTE_COUNTER         ; print error message
    jsr printCRLF
    rts
.showValuesAtEnd
    jsr showCalcNoSaveHires            ; print info about values used for calculation   
    cmp #CONST_CONTINUE
    beq .checkForKeyPress
    rts

; --------------------------------------------------
; This routine is the main entry point of the program
; --------------------------------------------------
progStart
    jsr initArithmetic
    +printStr .TXT_SELECT
    stz .INTERRUPTED

.inputSelect
    ; Handle inital menu
    jsr waitForKey
    cmp #49                            ; 1. pressed?
    bne .checkFor2                     ; No
    jmp loadAndShowPicture             ; yes => load and show picture
.checkFor2
    cmp #50                            ; 2. pressed?
    beq .useCurrent                    ; yes
    cmp #51                            ; 3. pressed?
    beq .resetCalcParms                ; yes
    cmp #52                            ; 4. pressed ?
    bne .inputSelect                   ; No => try again
    ; 4. was pressed
    rts

.resetCalcParms
    jsr resetParametersHires
.useCurrent
    jsr selectIterationDepth           ; let user select iteration depth
.restart
    jsr bitMapOn                       ; This also clears Video RAM
.continuePic
    jsr mandelLoop

.testInterrupted
    lda .INTERRUPTED
    beq .picDone                       ; user did not interrupt => picture is done
    cmp #KEY_DO_ZOOM                   ; F5 was pressed => Let user select a new section and zoom level
    bne .showInfo                      ; Another key was pressed

.doZoomIn
    jsr showZoomRect                   ; Perform selection of zoomed in section
    lda ZOOM_RESULT
    cmp #ZOOM_ESCAPE                   ; Did user cancel the operation?
    beq .continuePic                   ; Yes, User escaped from zoom selection
    jsr .processZoomResult             ; Modify state and start values for calculation
    stz .INTERRUPTED
    jmp .restart                       ; restart calculation with new values
.showInfo                              ; show info about values used for calculation
    jsr showCalcParameters
    cmp #CONST_FINISH
    beq .endMandel
    jmp .continuePic                   

.picDone                                ; handle UI stuff after calculation is done
    jmp handlePicDone
.endMandel
    stz .INTERRUPTED                   ; Make program forget that it was interrupted => calculation starts anew after running it again
    rts

} else {

TXT_PRECALCULATING
!byte 19
!tx "PRECALCULATING ... "
!byte 13

TXT_DONE
!byte 6
!tx "DONE."
!byte 13

; --------------------------------------------------
; Run tests only
; --------------------------------------------------
!zone tests
!source "tests.a"

progStart
    +printStr TXT_PRECALCULATING
    jsr initArithmetic    
    +printStr TXT_DONE
    jsr testMain
    rts
}

PROG_END
    !byte 0